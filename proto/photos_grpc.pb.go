// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.4
// source: proto/photos.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ByteService_Upload_FullMethodName            = "/photos.ByteService/Upload"
	ByteService_Download_FullMethodName          = "/photos.ByteService/Download"
	ByteService_StreamingUpload_FullMethodName   = "/photos.ByteService/StreamingUpload"
	ByteService_StreamingDownload_FullMethodName = "/photos.ByteService/StreamingDownload"
)

// ByteServiceClient is the client API for ByteService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ByteService provides photo upload, retrieval, and deletion operations
type ByteServiceClient interface {
	// Upload uploads a new photo
	Upload(ctx context.Context, in *UploadRequest, opts ...grpc.CallOption) (*UploadResponse, error)
	// Download retrieves a photo by ID
	Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (*DownloadResponse, error)
	// StreamingUpload uploads a photo using client-side streaming for large files
	StreamingUpload(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[StreamingUploadRequest, UploadResponse], error)
	// StreamingDownload downloads a photo using server-side streaming for large files
	StreamingDownload(ctx context.Context, in *StreamingDownloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamingDownloadResponse], error)
}

type byteServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewByteServiceClient(cc grpc.ClientConnInterface) ByteServiceClient {
	return &byteServiceClient{cc}
}

func (c *byteServiceClient) Upload(ctx context.Context, in *UploadRequest, opts ...grpc.CallOption) (*UploadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadResponse)
	err := c.cc.Invoke(ctx, ByteService_Upload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *byteServiceClient) Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (*DownloadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DownloadResponse)
	err := c.cc.Invoke(ctx, ByteService_Download_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *byteServiceClient) StreamingUpload(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[StreamingUploadRequest, UploadResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ByteService_ServiceDesc.Streams[0], ByteService_StreamingUpload_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamingUploadRequest, UploadResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ByteService_StreamingUploadClient = grpc.ClientStreamingClient[StreamingUploadRequest, UploadResponse]

func (c *byteServiceClient) StreamingDownload(ctx context.Context, in *StreamingDownloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamingDownloadResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ByteService_ServiceDesc.Streams[1], ByteService_StreamingDownload_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamingDownloadRequest, StreamingDownloadResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ByteService_StreamingDownloadClient = grpc.ServerStreamingClient[StreamingDownloadResponse]

// ByteServiceServer is the server API for ByteService service.
// All implementations must embed UnimplementedByteServiceServer
// for forward compatibility.
//
// ByteService provides photo upload, retrieval, and deletion operations
type ByteServiceServer interface {
	// Upload uploads a new photo
	Upload(context.Context, *UploadRequest) (*UploadResponse, error)
	// Download retrieves a photo by ID
	Download(context.Context, *DownloadRequest) (*DownloadResponse, error)
	// StreamingUpload uploads a photo using client-side streaming for large files
	StreamingUpload(grpc.ClientStreamingServer[StreamingUploadRequest, UploadResponse]) error
	// StreamingDownload downloads a photo using server-side streaming for large files
	StreamingDownload(*StreamingDownloadRequest, grpc.ServerStreamingServer[StreamingDownloadResponse]) error
	mustEmbedUnimplementedByteServiceServer()
}

// UnimplementedByteServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedByteServiceServer struct{}

func (UnimplementedByteServiceServer) Upload(context.Context, *UploadRequest) (*UploadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Upload not implemented")
}
func (UnimplementedByteServiceServer) Download(context.Context, *DownloadRequest) (*DownloadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Download not implemented")
}
func (UnimplementedByteServiceServer) StreamingUpload(grpc.ClientStreamingServer[StreamingUploadRequest, UploadResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamingUpload not implemented")
}
func (UnimplementedByteServiceServer) StreamingDownload(*StreamingDownloadRequest, grpc.ServerStreamingServer[StreamingDownloadResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamingDownload not implemented")
}
func (UnimplementedByteServiceServer) mustEmbedUnimplementedByteServiceServer() {}
func (UnimplementedByteServiceServer) testEmbeddedByValue()                     {}

// UnsafeByteServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ByteServiceServer will
// result in compilation errors.
type UnsafeByteServiceServer interface {
	mustEmbedUnimplementedByteServiceServer()
}

func RegisterByteServiceServer(s grpc.ServiceRegistrar, srv ByteServiceServer) {
	// If the following call panics, it indicates UnimplementedByteServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ByteService_ServiceDesc, srv)
}

func _ByteService_Upload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ByteServiceServer).Upload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ByteService_Upload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ByteServiceServer).Upload(ctx, req.(*UploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ByteService_Download_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ByteServiceServer).Download(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ByteService_Download_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ByteServiceServer).Download(ctx, req.(*DownloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ByteService_StreamingUpload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ByteServiceServer).StreamingUpload(&grpc.GenericServerStream[StreamingUploadRequest, UploadResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ByteService_StreamingUploadServer = grpc.ClientStreamingServer[StreamingUploadRequest, UploadResponse]

func _ByteService_StreamingDownload_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamingDownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ByteServiceServer).StreamingDownload(m, &grpc.GenericServerStream[StreamingDownloadRequest, StreamingDownloadResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ByteService_StreamingDownloadServer = grpc.ServerStreamingServer[StreamingDownloadResponse]

// ByteService_ServiceDesc is the grpc.ServiceDesc for ByteService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ByteService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "photos.ByteService",
	HandlerType: (*ByteServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Upload",
			Handler:    _ByteService_Upload_Handler,
		},
		{
			MethodName: "Download",
			Handler:    _ByteService_Download_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamingUpload",
			Handler:       _ByteService_StreamingUpload_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamingDownload",
			Handler:       _ByteService_StreamingDownload_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/photos.proto",
}

const (
	LibraryService_DeletePhoto_FullMethodName         = "/photos.LibraryService/DeletePhoto"
	LibraryService_GetPhoto_FullMethodName            = "/photos.LibraryService/GetPhoto"
	LibraryService_ListPhotos_FullMethodName          = "/photos.LibraryService/ListPhotos"
	LibraryService_CopyPhoto_FullMethodName           = "/photos.LibraryService/CopyPhoto"
	LibraryService_RenamePhoto_FullMethodName         = "/photos.LibraryService/RenamePhoto"
	LibraryService_UpdatePhotoMetadata_FullMethodName = "/photos.LibraryService/UpdatePhotoMetadata"
	LibraryService_GenerateSignedUrl_FullMethodName   = "/photos.LibraryService/GenerateSignedUrl"
	LibraryService_PhotoExists_FullMethodName         = "/photos.LibraryService/PhotoExists"
	LibraryService_ListDirectories_FullMethodName     = "/photos.LibraryService/ListDirectories"
	LibraryService_SyncDatabase_FullMethodName        = "/photos.LibraryService/SyncDatabase"
	LibraryService_CreateMarkdown_FullMethodName      = "/photos.LibraryService/CreateMarkdown"
	LibraryService_GetMarkdown_FullMethodName         = "/photos.LibraryService/GetMarkdown"
	LibraryService_UpdateMarkdown_FullMethodName      = "/photos.LibraryService/UpdateMarkdown"
	LibraryService_DeleteMarkdown_FullMethodName      = "/photos.LibraryService/DeleteMarkdown"
)

// LibraryServiceClient is the client API for LibraryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LibraryServiceClient interface {
	// DeletePhoto removes a photo by ID
	DeletePhoto(ctx context.Context, in *DeletePhotoRequest, opts ...grpc.CallOption) (*DeletePhotoResponse, error)
	// GetPhoto retrieves photo metadata by ID
	GetPhoto(ctx context.Context, in *GetPhotoRequest, opts ...grpc.CallOption) (*GetPhotoResponse, error)
	// ListPhotos returns a paginated list of photos with optional prefix filtering
	ListPhotos(ctx context.Context, in *ListPhotosRequest, opts ...grpc.CallOption) (*ListPhotosResponse, error)
	// CopyPhoto copies a photo to a new location
	CopyPhoto(ctx context.Context, in *CopyPhotoRequest, opts ...grpc.CallOption) (*CopyPhotoResponse, error)
	// RenamePhoto renames a photo by moving it to a new object ID
	RenamePhoto(ctx context.Context, in *RenamePhotoRequest, opts ...grpc.CallOption) (*RenamePhotoResponse, error)
	// UpdatePhotoMetadata updates metadata for a photo
	UpdatePhotoMetadata(ctx context.Context, in *UpdatePhotoMetadataRequest, opts ...grpc.CallOption) (*UpdatePhotoMetadataResponse, error)
	// GenerateSignedUrl creates a time-limited signed URL for photo access
	GenerateSignedUrl(ctx context.Context, in *GenerateSignedUrlRequest, opts ...grpc.CallOption) (*GenerateSignedUrlResponse, error)
	// PhotoExists checks if a photo exists by ID
	PhotoExists(ctx context.Context, in *PhotoExistsRequest, opts ...grpc.CallOption) (*PhotoExistsResponse, error)
	// ListDirectories lists virtual directories (common prefixes) in a bucket
	ListDirectories(ctx context.Context, in *ListDirectoriesRequest, opts ...grpc.CallOption) (*ListDirectoriesResponse, error)
	// SyncDatabase syncs the photo database with the storage backend
	SyncDatabase(ctx context.Context, in *SyncDatabaseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CreateMarkdown creates an index.md file in a specified prefix (directory)
	CreateMarkdown(ctx context.Context, in *CreateMarkdownRequest, opts ...grpc.CallOption) (*CreateMarkdownResponse, error)
	// GetMarkdown retrieves an index.md file from a specified prefix (directory)
	GetMarkdown(ctx context.Context, in *GetMarkdownRequest, opts ...grpc.CallOption) (*GetMarkdownResponse, error)
	// UpdateMarkdown updates an existing index.md file in a specified prefix (directory)
	UpdateMarkdown(ctx context.Context, in *UpdateMarkdownRequest, opts ...grpc.CallOption) (*UpdateMarkdownResponse, error)
	// DeleteMarkdown deletes an index.md file from a specified prefix (directory)
	DeleteMarkdown(ctx context.Context, in *DeleteMarkdownRequest, opts ...grpc.CallOption) (*DeleteMarkdownResponse, error)
}

type libraryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLibraryServiceClient(cc grpc.ClientConnInterface) LibraryServiceClient {
	return &libraryServiceClient{cc}
}

func (c *libraryServiceClient) DeletePhoto(ctx context.Context, in *DeletePhotoRequest, opts ...grpc.CallOption) (*DeletePhotoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeletePhotoResponse)
	err := c.cc.Invoke(ctx, LibraryService_DeletePhoto_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *libraryServiceClient) GetPhoto(ctx context.Context, in *GetPhotoRequest, opts ...grpc.CallOption) (*GetPhotoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPhotoResponse)
	err := c.cc.Invoke(ctx, LibraryService_GetPhoto_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *libraryServiceClient) ListPhotos(ctx context.Context, in *ListPhotosRequest, opts ...grpc.CallOption) (*ListPhotosResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPhotosResponse)
	err := c.cc.Invoke(ctx, LibraryService_ListPhotos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *libraryServiceClient) CopyPhoto(ctx context.Context, in *CopyPhotoRequest, opts ...grpc.CallOption) (*CopyPhotoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CopyPhotoResponse)
	err := c.cc.Invoke(ctx, LibraryService_CopyPhoto_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *libraryServiceClient) RenamePhoto(ctx context.Context, in *RenamePhotoRequest, opts ...grpc.CallOption) (*RenamePhotoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RenamePhotoResponse)
	err := c.cc.Invoke(ctx, LibraryService_RenamePhoto_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *libraryServiceClient) UpdatePhotoMetadata(ctx context.Context, in *UpdatePhotoMetadataRequest, opts ...grpc.CallOption) (*UpdatePhotoMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePhotoMetadataResponse)
	err := c.cc.Invoke(ctx, LibraryService_UpdatePhotoMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *libraryServiceClient) GenerateSignedUrl(ctx context.Context, in *GenerateSignedUrlRequest, opts ...grpc.CallOption) (*GenerateSignedUrlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateSignedUrlResponse)
	err := c.cc.Invoke(ctx, LibraryService_GenerateSignedUrl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *libraryServiceClient) PhotoExists(ctx context.Context, in *PhotoExistsRequest, opts ...grpc.CallOption) (*PhotoExistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PhotoExistsResponse)
	err := c.cc.Invoke(ctx, LibraryService_PhotoExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *libraryServiceClient) ListDirectories(ctx context.Context, in *ListDirectoriesRequest, opts ...grpc.CallOption) (*ListDirectoriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDirectoriesResponse)
	err := c.cc.Invoke(ctx, LibraryService_ListDirectories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *libraryServiceClient) SyncDatabase(ctx context.Context, in *SyncDatabaseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LibraryService_SyncDatabase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *libraryServiceClient) CreateMarkdown(ctx context.Context, in *CreateMarkdownRequest, opts ...grpc.CallOption) (*CreateMarkdownResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateMarkdownResponse)
	err := c.cc.Invoke(ctx, LibraryService_CreateMarkdown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *libraryServiceClient) GetMarkdown(ctx context.Context, in *GetMarkdownRequest, opts ...grpc.CallOption) (*GetMarkdownResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMarkdownResponse)
	err := c.cc.Invoke(ctx, LibraryService_GetMarkdown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *libraryServiceClient) UpdateMarkdown(ctx context.Context, in *UpdateMarkdownRequest, opts ...grpc.CallOption) (*UpdateMarkdownResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateMarkdownResponse)
	err := c.cc.Invoke(ctx, LibraryService_UpdateMarkdown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *libraryServiceClient) DeleteMarkdown(ctx context.Context, in *DeleteMarkdownRequest, opts ...grpc.CallOption) (*DeleteMarkdownResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMarkdownResponse)
	err := c.cc.Invoke(ctx, LibraryService_DeleteMarkdown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LibraryServiceServer is the server API for LibraryService service.
// All implementations must embed UnimplementedLibraryServiceServer
// for forward compatibility.
type LibraryServiceServer interface {
	// DeletePhoto removes a photo by ID
	DeletePhoto(context.Context, *DeletePhotoRequest) (*DeletePhotoResponse, error)
	// GetPhoto retrieves photo metadata by ID
	GetPhoto(context.Context, *GetPhotoRequest) (*GetPhotoResponse, error)
	// ListPhotos returns a paginated list of photos with optional prefix filtering
	ListPhotos(context.Context, *ListPhotosRequest) (*ListPhotosResponse, error)
	// CopyPhoto copies a photo to a new location
	CopyPhoto(context.Context, *CopyPhotoRequest) (*CopyPhotoResponse, error)
	// RenamePhoto renames a photo by moving it to a new object ID
	RenamePhoto(context.Context, *RenamePhotoRequest) (*RenamePhotoResponse, error)
	// UpdatePhotoMetadata updates metadata for a photo
	UpdatePhotoMetadata(context.Context, *UpdatePhotoMetadataRequest) (*UpdatePhotoMetadataResponse, error)
	// GenerateSignedUrl creates a time-limited signed URL for photo access
	GenerateSignedUrl(context.Context, *GenerateSignedUrlRequest) (*GenerateSignedUrlResponse, error)
	// PhotoExists checks if a photo exists by ID
	PhotoExists(context.Context, *PhotoExistsRequest) (*PhotoExistsResponse, error)
	// ListDirectories lists virtual directories (common prefixes) in a bucket
	ListDirectories(context.Context, *ListDirectoriesRequest) (*ListDirectoriesResponse, error)
	// SyncDatabase syncs the photo database with the storage backend
	SyncDatabase(context.Context, *SyncDatabaseRequest) (*emptypb.Empty, error)
	// CreateMarkdown creates an index.md file in a specified prefix (directory)
	CreateMarkdown(context.Context, *CreateMarkdownRequest) (*CreateMarkdownResponse, error)
	// GetMarkdown retrieves an index.md file from a specified prefix (directory)
	GetMarkdown(context.Context, *GetMarkdownRequest) (*GetMarkdownResponse, error)
	// UpdateMarkdown updates an existing index.md file in a specified prefix (directory)
	UpdateMarkdown(context.Context, *UpdateMarkdownRequest) (*UpdateMarkdownResponse, error)
	// DeleteMarkdown deletes an index.md file from a specified prefix (directory)
	DeleteMarkdown(context.Context, *DeleteMarkdownRequest) (*DeleteMarkdownResponse, error)
	mustEmbedUnimplementedLibraryServiceServer()
}

// UnimplementedLibraryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLibraryServiceServer struct{}

func (UnimplementedLibraryServiceServer) DeletePhoto(context.Context, *DeletePhotoRequest) (*DeletePhotoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeletePhoto not implemented")
}
func (UnimplementedLibraryServiceServer) GetPhoto(context.Context, *GetPhotoRequest) (*GetPhotoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPhoto not implemented")
}
func (UnimplementedLibraryServiceServer) ListPhotos(context.Context, *ListPhotosRequest) (*ListPhotosResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPhotos not implemented")
}
func (UnimplementedLibraryServiceServer) CopyPhoto(context.Context, *CopyPhotoRequest) (*CopyPhotoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CopyPhoto not implemented")
}
func (UnimplementedLibraryServiceServer) RenamePhoto(context.Context, *RenamePhotoRequest) (*RenamePhotoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RenamePhoto not implemented")
}
func (UnimplementedLibraryServiceServer) UpdatePhotoMetadata(context.Context, *UpdatePhotoMetadataRequest) (*UpdatePhotoMetadataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePhotoMetadata not implemented")
}
func (UnimplementedLibraryServiceServer) GenerateSignedUrl(context.Context, *GenerateSignedUrlRequest) (*GenerateSignedUrlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GenerateSignedUrl not implemented")
}
func (UnimplementedLibraryServiceServer) PhotoExists(context.Context, *PhotoExistsRequest) (*PhotoExistsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PhotoExists not implemented")
}
func (UnimplementedLibraryServiceServer) ListDirectories(context.Context, *ListDirectoriesRequest) (*ListDirectoriesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDirectories not implemented")
}
func (UnimplementedLibraryServiceServer) SyncDatabase(context.Context, *SyncDatabaseRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method SyncDatabase not implemented")
}
func (UnimplementedLibraryServiceServer) CreateMarkdown(context.Context, *CreateMarkdownRequest) (*CreateMarkdownResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateMarkdown not implemented")
}
func (UnimplementedLibraryServiceServer) GetMarkdown(context.Context, *GetMarkdownRequest) (*GetMarkdownResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMarkdown not implemented")
}
func (UnimplementedLibraryServiceServer) UpdateMarkdown(context.Context, *UpdateMarkdownRequest) (*UpdateMarkdownResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateMarkdown not implemented")
}
func (UnimplementedLibraryServiceServer) DeleteMarkdown(context.Context, *DeleteMarkdownRequest) (*DeleteMarkdownResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteMarkdown not implemented")
}
func (UnimplementedLibraryServiceServer) mustEmbedUnimplementedLibraryServiceServer() {}
func (UnimplementedLibraryServiceServer) testEmbeddedByValue()                        {}

// UnsafeLibraryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LibraryServiceServer will
// result in compilation errors.
type UnsafeLibraryServiceServer interface {
	mustEmbedUnimplementedLibraryServiceServer()
}

func RegisterLibraryServiceServer(s grpc.ServiceRegistrar, srv LibraryServiceServer) {
	// If the following call panics, it indicates UnimplementedLibraryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LibraryService_ServiceDesc, srv)
}

func _LibraryService_DeletePhoto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePhotoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LibraryServiceServer).DeletePhoto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LibraryService_DeletePhoto_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LibraryServiceServer).DeletePhoto(ctx, req.(*DeletePhotoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LibraryService_GetPhoto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPhotoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LibraryServiceServer).GetPhoto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LibraryService_GetPhoto_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LibraryServiceServer).GetPhoto(ctx, req.(*GetPhotoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LibraryService_ListPhotos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPhotosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LibraryServiceServer).ListPhotos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LibraryService_ListPhotos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LibraryServiceServer).ListPhotos(ctx, req.(*ListPhotosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LibraryService_CopyPhoto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyPhotoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LibraryServiceServer).CopyPhoto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LibraryService_CopyPhoto_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LibraryServiceServer).CopyPhoto(ctx, req.(*CopyPhotoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LibraryService_RenamePhoto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenamePhotoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LibraryServiceServer).RenamePhoto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LibraryService_RenamePhoto_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LibraryServiceServer).RenamePhoto(ctx, req.(*RenamePhotoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LibraryService_UpdatePhotoMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePhotoMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LibraryServiceServer).UpdatePhotoMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LibraryService_UpdatePhotoMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LibraryServiceServer).UpdatePhotoMetadata(ctx, req.(*UpdatePhotoMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LibraryService_GenerateSignedUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateSignedUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LibraryServiceServer).GenerateSignedUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LibraryService_GenerateSignedUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LibraryServiceServer).GenerateSignedUrl(ctx, req.(*GenerateSignedUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LibraryService_PhotoExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhotoExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LibraryServiceServer).PhotoExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LibraryService_PhotoExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LibraryServiceServer).PhotoExists(ctx, req.(*PhotoExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LibraryService_ListDirectories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDirectoriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LibraryServiceServer).ListDirectories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LibraryService_ListDirectories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LibraryServiceServer).ListDirectories(ctx, req.(*ListDirectoriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LibraryService_SyncDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LibraryServiceServer).SyncDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LibraryService_SyncDatabase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LibraryServiceServer).SyncDatabase(ctx, req.(*SyncDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LibraryService_CreateMarkdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMarkdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LibraryServiceServer).CreateMarkdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LibraryService_CreateMarkdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LibraryServiceServer).CreateMarkdown(ctx, req.(*CreateMarkdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LibraryService_GetMarkdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarkdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LibraryServiceServer).GetMarkdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LibraryService_GetMarkdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LibraryServiceServer).GetMarkdown(ctx, req.(*GetMarkdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LibraryService_UpdateMarkdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarkdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LibraryServiceServer).UpdateMarkdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LibraryService_UpdateMarkdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LibraryServiceServer).UpdateMarkdown(ctx, req.(*UpdateMarkdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LibraryService_DeleteMarkdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMarkdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LibraryServiceServer).DeleteMarkdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LibraryService_DeleteMarkdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LibraryServiceServer).DeleteMarkdown(ctx, req.(*DeleteMarkdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LibraryService_ServiceDesc is the grpc.ServiceDesc for LibraryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LibraryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "photos.LibraryService",
	HandlerType: (*LibraryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeletePhoto",
			Handler:    _LibraryService_DeletePhoto_Handler,
		},
		{
			MethodName: "GetPhoto",
			Handler:    _LibraryService_GetPhoto_Handler,
		},
		{
			MethodName: "ListPhotos",
			Handler:    _LibraryService_ListPhotos_Handler,
		},
		{
			MethodName: "CopyPhoto",
			Handler:    _LibraryService_CopyPhoto_Handler,
		},
		{
			MethodName: "RenamePhoto",
			Handler:    _LibraryService_RenamePhoto_Handler,
		},
		{
			MethodName: "UpdatePhotoMetadata",
			Handler:    _LibraryService_UpdatePhotoMetadata_Handler,
		},
		{
			MethodName: "GenerateSignedUrl",
			Handler:    _LibraryService_GenerateSignedUrl_Handler,
		},
		{
			MethodName: "PhotoExists",
			Handler:    _LibraryService_PhotoExists_Handler,
		},
		{
			MethodName: "ListDirectories",
			Handler:    _LibraryService_ListDirectories_Handler,
		},
		{
			MethodName: "SyncDatabase",
			Handler:    _LibraryService_SyncDatabase_Handler,
		},
		{
			MethodName: "CreateMarkdown",
			Handler:    _LibraryService_CreateMarkdown_Handler,
		},
		{
			MethodName: "GetMarkdown",
			Handler:    _LibraryService_GetMarkdown_Handler,
		},
		{
			MethodName: "UpdateMarkdown",
			Handler:    _LibraryService_UpdateMarkdown_Handler,
		},
		{
			MethodName: "DeleteMarkdown",
			Handler:    _LibraryService_DeleteMarkdown_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/photos.proto",
}
